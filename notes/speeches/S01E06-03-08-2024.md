# S01E06 — 03-08-2024.

> *Ça fonctionne !*

[prev](S01E05-02-08-2024.md) — [next](S01E01-29-07-2024.md)

## jour 6.

Sayé ! J'ai un interpréteur opérationnel pour faire des calculs. Pour l'instant il prend en compte que les nombres entiers et accepte que les opérations binaires du type addition essentiellement. Ce qui est parfait, puisque aujourd'hui c'est samedi et la deadline est fixée à dimanche soir. Ce qui me laisse pas mal de temps pour étendre les opérations binaires.

A savoir qu'avec la structure actuelle de mon projet ça va se faire rapidement. Par exemple, pour ajouter le support de la soustraction, je n'ai besoin que d'une seule ligne :   

```rs
BinOpKind::Sub => Ok(Value::int(lhs - rhs, span))
```

En testant ça fonctionne bien. Par contre, selon moi, ça ne devrait pas fonctionner. Puisque `lhs` et `rhs` sont respectivement des `Value` pour être capable d'effectuer une soustraction, l'instance `Value` devrait implémenter le trait `std::ops::Sub`. Ce qui lui donnerait la légitimité d'effectuer des soustractions. Actuellement ce n'est pas le cas et pourtant, le compilateur Rust ne me signale aucune erreur. De plus, lorsque j'exécute mon compilateur pour interpréter `1234 - 123`, il me donne bien le bon résultat, c'est-à-dire `1111`.

En temps normal, je devrais avoir à ajouter les lignes suivantes :    

```rs
impl std::ops::Sub for &Value {
  type Output = Value;

  fn sub(self, rhs: Self) -> Self::Output {
    match (&self.kind, &rhs.kind) {
      (ValueKind::Int(lhs), ValueKind::Int(rhs)) => {
        Value::int(lhs - rhs, Span::ZERO)
      }
      _ => unreachable!(),
    }
  }
}
```

Alors que sans ces lignes, ça fonctionne tout de même. Le pire, c'est que ça fonctionne pour plusieurs les opérateurs. Si je change par une multiplication :

```rs
BinOpKind::Sub => Ok(Value::int(lhs * rhs, span))
//                                  ^
//                                 mul
```

Le résultat de `1234 * 123` devient `151782`. Il doit y avoir un couac dans mon compilo ou le compilo Rust est instable. Il y a un bug quelque part. On dirait que lorsqu'on implémente le trait `std::ops::Add`, l'ensemble des autress opérations `Sub`, `Mul`, `Div`, `Rem` sont supportés. Je n'ai pas encore fait de tests pour `BitAnd`, `BitOr`, `BitXor`, `Shl` ou `Shr`. Mais vu le comportement acutel, je ne serais pas surpris que ça fonctionne. Pas grave, je vais laisser comme ça, le temps que j'investigue, même si cela peut porter à confusion.

Au final, ce que je retiens, c'est que j'ai mon petit compilo. Il est 15h45 au moment où j'écris cette ligne donc je suis bien pour me faire une petite calculette pour les `int` et `float`. De cette base, je pourrai me renseigner sur l'inférence de type. Je comprends le concept, mais pour l'implémenter.................................... j'y comprends que dalle. Il faut suivre l'algorithme Hindley-Milner ou l'algorithme W, cependant lorsque tu n'as rien branlé pendant les cours de mathématiques comme moi. Bah des années après, tu te manges la porte blindée, le mur en adamantium, à te demander s'il n'est pas venu le temps de prendre des cours particuliers pour être capable de comprendre et d'avancer. C'est dans un coin de ma tête.

En attendant, j'ai trouvé un repo sur github qui implémente l'inférence de type en rust. C'est clair à comprendre sur les examples simples et il y a plusieurs dérivés pour être adapté au besoin.    

- [typical](https://github.com/ravern/typical/tree/master) by [ravern](https://github.com/ravern).

[@invisageable](https://twitter.com/invisageable)   

---

[prev](S01E05-02-08-2024.md) — [next](S01E01-29-07-2024.md)
