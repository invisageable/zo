(* ========================================================================= *)
(*  Fret Configuration File Grammar (`.oz`) - Version 2.0                    *)
(*  Supports Directive Assignment and Namespacing.                           *)
(* ========================================================================= *)

(* --- Whitespace and Comments --- *)
(* 
  Whitespace (spaces, tabs, newlines) and comments are implicitly allowed
  between any of the tokens and should be skipped by the tokenizer.
*)
comment = "--", { ? any character except newline ? } ;

(* --- Top Level --- *)
(* A `fret.oz` file is a sequence of zero or more directive assignments. *)
config_file = { directive_assignment } ;


(* --- Core Structures --- *)

(* A directive assignment binds a value to a directive path. *)
directive_assignment = directive_path, "=", value, ";" ;

(* A directive path starts with '@' and can have multiple, colon-separated segments. *)
directive_path = "@", identifier, { ":", identifier } ;

(* A value can be a tuple of key-value pairs, an array, or a simple literal. *)
value = 
    value_tuple
  | array
  | string_literal
  | integer_literal ;

(* A tuple holds a comma-separated list of key-value pairs. *)
value_tuple = "(", [ pair, { ",", pair } ], [ "," ], ")" ;

(* A key-value pair. The key is always an identifier. *)
pair = identifier, ":", value ;

(* An array is a comma-separated list of values inside square brackets. *)
array = "[", [ value, { ",", value } ], [ "," ], "]" ;


(* --- Terminals (Lexer Tokens) --- *)

(* An identifier starts with a letter, followed by letters, digits, or underscores. *)
identifier = letter, { letter | digit | "_" } ;

(* A string literal is enclosed in double quotes with support for escaped quotes. *)
string_literal = '"', { character | escape_sequence }, '"' ;

(* An integer literal is a sequence of one or more digits. *)
integer_literal = digit, { digit } ;


(* --- Character Classes --- *)

letter = ? A-Z or a-z ? ;
digit = ? 0-9 ? ;
character = ? any character except '"' or '\' ? ;
escape_sequence = '\', '"' ;
